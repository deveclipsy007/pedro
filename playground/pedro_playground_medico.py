"""
Agno Playground para o Agente Pedro - Vers√£o M√©dica Profissional
Interface web direcionada a m√©dicos pediatras, residentes e emergencistas
"""

import os
import sys
from pathlib import Path
from dotenv import load_dotenv
from typing import List, Dict, Optional

# Adiciona o diret√≥rio raiz ao path para imports
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from agno.agent import Agent
from agno.tools import tool
from agno.playground import Playground, serve_playground_app

# Importa m√≥dulos do Pedro
try:
    from pedro_enhanced_search import PedroEnhancedSearch
    from pubmed_integration import PedroWithPubMed
except ImportError as e:
    print(f"‚ö†Ô∏è Erro ao importar m√≥dulos do Pedro: {e}")
    print("Usando fallback para busca simples")
    PedroEnhancedSearch = None
    PedroWithPubMed = None

import sqlite3

# Importa integra√ß√£o PubMed
try:
    from pubmed_integration import PedroWithPubMed
    PUBMED_AVAILABLE = True
    print("üî¨ Integra√ß√£o PubMed dispon√≠vel!")
except ImportError:
    PUBMED_AVAILABLE = False
    print("‚ö†Ô∏è Integra√ß√£o PubMed n√£o dispon√≠vel")

# Caminho para o banco RAG
DB_PATH = Path(__file__).parent.parent / "data" / "enhanced_rag.db"

# Carrega vari√°veis de ambiente
load_dotenv('.env.test')

# Inicializa sistema de busca aprimorado
enhanced_search_instance = None
if PedroEnhancedSearch:
    try:
        enhanced_search_instance = PedroEnhancedSearch(str(DB_PATH))
        print("üöÄ Sistema de busca aprimorado ativado!")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao inicializar busca aprimorada: {e}")
        enhanced_search_instance = None

# Inicializa integra√ß√£o PubMed se dispon√≠vel
pubmed_instance = None
if PUBMED_AVAILABLE:
    try:
        pubmed_api_key = os.getenv('PUBMED_API_KEY', '')
        pubmed_instance = PedroWithPubMed(pubmed_api_key)
        print("üî¨ Pedro com PubMed inicializado!")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao inicializar PubMed: {e}")
        pubmed_instance = None

def is_complex_query(query: str) -> bool:
    """Determina se uma query √© complexa o suficiente para usar busca sem√¢ntica"""
    complex_indicators = [
        len(query.split()) >= 4,  # 4+ palavras
        any(word in query.lower() for word in ['e', 'em', 'para', 'com', 'de', 'da', 'do']),  # conectores
        any(word in query.lower() for word in ['lactente', 'crian√ßa', 'pediatria', 'anos', 'meses']),  # contexto pedi√°trico
        any(word in query.lower() for word in ['dose', 'mg/kg', 'protocolo', 'tratamento']),  # termos cl√≠nicos
        any(word in query.lower() for word in ['apneia', 'insufici√™ncia', 'respirat√≥ria', 'card√≠aca'])  # condi√ß√µes complexas
    ]
    return sum(complex_indicators) >= 2

def search_rag_database(query: str, limit: int = 5):
    """Busca direta no banco RAG com l√≥gica OR para maior cobertura"""
    try:
        conn = sqlite3.connect(str(DB_PATH))
        cursor = conn.cursor()
        
        # Busca nos chunks usando OR para maior cobertura
        search_terms = query.lower().split()
        where_conditions = []
        params = []
        
        for term in search_terms:
            where_conditions.append("LOWER(chunk_text) LIKE ?")
            params.append(f"%{term}%")
        
        # Usa OR ao inv√©s de AND para encontrar chunks com qualquer termo
        where_clause = " OR ".join(where_conditions)
        
        sql = f"""
        SELECT c.chunk_text, c.semantic_tags, c.keywords, d.filename 
        FROM semantic_chunks c
        JOIN documents d ON c.document_id = d.id
        WHERE {where_clause}
        ORDER BY c.id
        LIMIT ?
        """
        
        params.append(limit)
        cursor.execute(sql, params)
        results = cursor.fetchall()
        conn.close()
        
        print(f"üîç Busca RAG: '{query}' ‚Üí {len(results)} chunks encontrados")
        return results
        
    except Exception as e:
        print(f"‚ùå Erro na busca RAG: {e}")
        return []

def retrieve_docs_core(query: str, limit: int = 3) -> str:
    """
    Fun√ß√£o principal de busca com detec√ß√£o autom√°tica de dose (SEM decorador @tool)
    """
    try:
        print(f"üîç CONSULTA CL√çNICA: '{query}'")
        
        # üßÆ DETEC√á√ÉO AUTOM√ÅTICA DE QUERIES DE DOSE
        dose_keywords = ['dose', 'dosagem', 'mg/kg', 'posologia', 'calcul']
        weight_pattern = r'(\d+)\s*kg'
        
        query_lower = query.lower()
        has_dose_keyword = any(keyword in query_lower for keyword in dose_keywords)
        
        import re
        weight_match = re.search(weight_pattern, query_lower)
        
        if has_dose_keyword and weight_match:
            # Verifica se √© uma query de dose/c√°lculo posol√≥gico
            dose_keywords = ['dose', 'dosagem', 'mg/kg', 'posologia']
            clinical_indications = ['sedacao', 'seda√ß√£o', 'analgesia', 'analgesia', 'convulsao', 'convuls√£o', 'premedicacao', 'premedica√ß√£o']
            medications = ['midazolam', 'paracetamol', 'ibuprofeno', 'amoxicilina', 'diazepam', 'morfina']
            
            is_dose_query = any(keyword in query_lower for keyword in dose_keywords)
            has_weight = any(word.endswith('kg') and word[:-2].replace('.', '').isdigit() for word in query.split())
            
            # Extrai medicamento e indica√ß√£o
            medication = next((med for med in medications if med in query_lower), None)
            indication = next((ind for ind in clinical_indications if ind in query_lower), "")
            
            # Extrai peso
            weight = None
            for word in query.split():
                if word.endswith('kg') and word[:-2].replace('.', '').isdigit():
                    try:
                        weight = float(word[:-2])
                        break
                    except ValueError:
                        continue
            
            print(f"üîç Palavras-chave de dose encontradas: {is_dose_query}")
            print(f"üîç Peso encontrado: {weight}")
            
            # Se for query de dose com peso, calcula automaticamente
            if is_dose_query and has_weight and medication and weight:
                print(f"üßÆ DETEC√á√ÉO AUTOM√ÅTICA ATIVADA!")
                print(f"Medicamento: {medication}")
                print(f"Peso: {weight} kg")
                print(f"Indica√ß√£o: {indication}")
                
                # Chama c√°lculo de dose usando a fun√ß√£o core (sem decorador)
                dose_result = calc_dose_core(medication, weight, indication=indication)
                
                # Combina resultado do c√°lculo com protocolos encontrados
                combined_result = f"{dose_result}\n\n---\n\nüìã **PROTOCOLOS CL√çNICOS ENCONTRADOS:**\n\n"
                
                results = search_rag_database(query, limit)
                if results:
                    for i, (content, tags, keywords, filename) in enumerate(results[:3], 1):
                        combined_result += f"**Protocolo {i}:** {filename}\n{content[:300]}...\n\n"
                else:
                    combined_result += "‚ö†Ô∏è Nenhum protocolo cl√≠nico encontrado."
                
                return combined_result
        
        # Se n√£o √© query de dose, executa busca normal
        return retrieve_docs_normal(query, limit)
        
    except Exception as e:
        return f"""**ERRO NA CONSULTA CL√çNICA**

**Query:** {query}
**Erro:** {str(e)}

**Alternativas:**
‚Ä¢ Verificar conectividade com banco RAG
‚Ä¢ Tentar pubmed_search para literatura cient√≠fica
‚Ä¢ Reformular query com termos mais espec√≠ficos

---
**STATUS:** Erro t√©cnico na consulta aos protocolos"""

@tool
def retrieve_docs(query: str, limit: int = 3) -> str:
    """
    Consulta diretrizes cl√≠nicas nos protocolos Pedlife validados
    
    Args:
        query: Termo cl√≠nico para consulta
        limit: N√∫mero m√°ximo de protocolos a consultar
        
    Returns:
        Diretrizes cl√≠nicas baseadas em protocolos validados
    """
    # Chama a fun√ß√£o principal sem decorador
    return retrieve_docs_core(query, limit)

def retrieve_docs_normal(query: str, limit: int = 3) -> str:
    """
    Fun√ß√£o auxiliar para busca normal nos protocolos (sem detec√ß√£o de dose)
    """
    try:
        # Usa sistema de busca aprimorado se dispon√≠vel
        if enhanced_search_instance:
            print("üöÄ Usando sistema de busca aprimorado...")
            
            # Busca aprimorada com sin√¥nimos e valida√ß√£o
            enhanced_results = enhanced_search_instance.enhanced_search(query, limit)
            
            if enhanced_results:
                # Valida clinicamente os resultados
                validation = enhanced_search_instance.validate_clinical_response(query, enhanced_results)
                
                # Formata resposta cl√≠nica aprimorada
                formatted_response = enhanced_search_instance.format_clinical_response(
                    query, enhanced_results, validation
                )
                
                return formatted_response
        
        # Fallback para busca direta no RAG
        print("üîç Usando busca direta no RAG...")
        rag_results = search_rag_database(query, limit)
        
        if not rag_results:
            return f"""**CONSULTA PEDLIFE - SEM RESULTADOS**

**Query:** {query}
**Status:** Nenhum protocolo encontrado para este termo

**Recomenda√ß√£o:** 
‚Ä¢ Tente termos mais espec√≠ficos ou sin√¥nimos
‚Ä¢ Use pubmed_search para literatura cient√≠fica
‚Ä¢ Verifique ortografia dos termos m√©dicos

---
**FONTE:** Protocolos Pedlife (busca direta)"""
        
        response_parts = [
            f"**PROTOCOLOS PEDLIFE - CONSULTA DIRETA**",
            f"**Query:** {query}",
            f"**Protocolos encontrados:** {len(rag_results)}",
            f"",
            f"**DADOS CL√çNICOS:**"
        ]
        
        for i, (chunk_text, tags, keywords, filename) in enumerate(rag_results, 1):
            content = chunk_text[:400] + "..." if len(chunk_text) > 400 else chunk_text
            response_parts.extend([
                f"",
                f"**{i}. {filename}**",
                f"‚Ä¢ **Conte√∫do:** {content}",
                f"‚Ä¢ **Tags:** {tags or 'N/A'}",
                f"‚Ä¢ **Palavras-chave:** {keywords or 'N/A'}"
            ])
        
        response_parts.extend([
            f"",
            f"---",
            f"**FONTE:** Protocolos Pedlife validados",
            f"**M√âTODO:** Busca direta no RAG"
        ])
        
        return "\n".join(response_parts)
        
    except Exception as e:
        return f"""**ERRO NA CONSULTA CL√çNICA**

**Query:** {query}
**Erro:** {str(e)}

**Alternativas:**
‚Ä¢ Verificar conectividade com banco RAG
‚Ä¢ Tentar pubmed_search para literatura cient√≠fica
‚Ä¢ Reformular query com termos mais espec√≠ficos

---
**STATUS:** Erro t√©cnico na consulta aos protocolos""" 

def calc_dose_core(medication: str, weight: float, age: int = None, indication: str = "") -> str:
    """
    Fun√ß√£o principal de c√°lculo de dose (SEM decorador @tool)
    """
    try:
        # Busca informa√ß√µes do medicamento nos protocolos
        med_query = f"{medication} dose pediatrica mg/kg"
        if indication:
            med_query += f" {indication}"
        
        results = search_rag_database(med_query, limit=3)
        
        # Dicion√°rio de doses por medicamento (valores padr√£o)
        dose_ranges = {
            'midazolam': {'min': 0.05, 'max': 0.2, 'unit': 'mg/kg'},
            'paracetamol': {'min': 10, 'max': 15, 'unit': 'mg/kg'},
            'ibuprofeno': {'min': 5, 'max': 10, 'unit': 'mg/kg'},
            'amoxicilina': {'min': 20, 'max': 40, 'unit': 'mg/kg'},
            'diazepam': {'min': 0.2, 'max': 0.5, 'unit': 'mg/kg'},
            'morfina': {'min': 0.05, 'max': 0.1, 'unit': 'mg/kg'}
        }
        
        # Verifica se o medicamento tem dose definida
        if medication.lower() not in dose_ranges:
            # Busca alternativas nos resultados
            if results:
                return f"""üíä **C√ÅLCULO POSOL√ìGICO PEDI√ÅTRICO**
üè• **Medicamento:** {medication.upper()}
‚öñÔ∏è **Peso:** {weight} kg

‚ö†Ô∏è **INFORMA√á√ïES ENCONTRADAS NOS PROTOCOLOS:**

{chr(10).join([f'‚Ä¢ {r.get("content", "")[:200]}...' for r in results[:2]])}

‚ö†Ô∏è **RECOMENDA√á√ÉO CL√çNICA:**
‚Ä¢ Verificar protocolos institucionais espec√≠ficos
‚Ä¢ Consultar refer√™ncias atualizadas
‚Ä¢ Validar com farmac√™utico cl√≠nico"""
            else:
                return f"""üíä **C√ÅLCULO POSOL√ìGICO PEDI√ÅTRICO**
üè• **Medicamento:** {medication.upper()}
‚öñÔ∏è **Peso:** {weight} kg

‚ùå **ERRO:** Medicamento n√£o encontrado nos protocolos

‚ö†Ô∏è **RECOMENDA√á√ÉO CL√çNICA:**
‚Ä¢ Verificar nome correto do medicamento
‚Ä¢ Consultar vadem√©cum pedi√°trico
‚Ä¢ Validar com farmac√™utico cl√≠nico"""
        
        # Calcula dose
        dose_info = dose_ranges[medication.lower()]
        min_dose = round(weight * dose_info['min'], 2)
        max_dose = round(weight * dose_info['max'], 2)
        
        # Formata resultado
        result = f"""üíä **C√ÅLCULO POSOL√ìGICO PEDI√ÅTRICO**
üè• **Medicamento:** {medication.upper()}
‚öñÔ∏è **Peso:** {weight} kg
üéØ **Indica√ß√£o:** {indication or 'geral'}

üßÆ **C√ÅLCULO ESPEC√çFICO {medication.upper()}:**
‚Ä¢ **Dose m√≠nima:** {min_dose} mg ({weight} kg √ó {dose_info['min']} mg/kg)
‚Ä¢ **Dose m√°xima:** {max_dose} mg ({weight} kg √ó {dose_info['max']} mg/kg)
‚Ä¢ **Via:** IV/IM
‚Ä¢ **Intervalo:** dose √∫nica ou conforme necess√°rio
‚Ä¢ **Dose recomendada para {weight}kg:** {min_dose} - {max_dose} mg

‚ö†Ô∏è **VALIDA√á√ÉO OBRIGAT√ìRIA:**
‚Ä¢ Verificar contraindica√ß√µes espec√≠ficas
‚Ä¢ Confirmar dose m√°xima permitida
‚Ä¢ Avaliar fun√ß√£o renal/hep√°tica
‚Ä¢ Considerar intera√ß√µes medicamentosas"""
        
        # Adiciona informa√ß√µes dos protocolos se dispon√≠veis
        if results:
            result += f"""

üìö **PROTOCOLOS COMPLEMENTARES:**
{chr(10).join([f'‚Ä¢ {r.get("source", "Fonte desconhecida")}: {r.get("content", "")[:150]}...' for r in results[:2]])}"""
        
        return result
        
    except Exception as e:
        return f"""üíä **C√ÅLCULO POSOL√ìGICO PEDI√ÅTRICO**
üè• **Medicamento:** {medication.upper()}
‚öñÔ∏è **Peso:** {weight} kg

‚ùå **ERRO NO C√ÅLCULO:** {str(e)}

‚ö†Ô∏è **RECOMENDA√á√ÉO CL√çNICA:**
‚Ä¢ Calcular manualmente com base em protocolos
‚Ä¢ Validar com farmac√™utico cl√≠nico
‚Ä¢ Considerar peso, idade e fun√ß√£o org√¢nica"""

@tool
def calc_dose(medication: str, weight: float, age: int = None, indication: str = "") -> str:
    """
    C√°lculo de posologia pedi√°trica baseado em protocolos validados
    
    Args:
        medication: Medicamento para c√°lculo posol√≥gico
        weight: Peso do paciente em kg
        age: Idade do paciente em anos (opcional)
        indication: Indica√ß√£o cl√≠nica espec√≠fica
        
    Returns:
        C√°lculo posol√≥gico com valida√ß√£o farmacol√≥gica
    """
    # Chama a fun√ß√£o principal sem decorador
    return calc_dose_core(medication, weight, age, indication)

def test_medical_scenarios(scenario_type: str = "dosage") -> str:
    """
    An√°lise de cen√°rios cl√≠nicos pedi√°tricos complexos
    
    Args:
        scenario_type: Tipo de cen√°rio (dosage, emergency, protocols)
{{ ... }}
        
    Returns:
        An√°lise de cen√°rios baseada em protocolos validados
    """
    try:
        scenarios = {
            "dosage": "Cen√°rios de c√°lculo posol√≥gico pedi√°trico",
            "emergency": "Protocolos de emerg√™ncia pedi√°trica",
            "protocols": "Diretrizes cl√≠nicas gerais",
            "respiratory": "Emerg√™ncias respirat√≥rias pedi√°tricas",
            "cardiac": "Emerg√™ncias cardiol√≥gicas pedi√°tricas"
        }
        
        scenario_name = scenarios.get(scenario_type, "Cen√°rio cl√≠nico geral")
        
        # Busca cen√°rios nos protocolos
        results = search_rag_database(f"{scenario_type} pediatrico emergencia", limit=3)
        
        response_parts = [
            f"üè• **AN√ÅLISE DE CEN√ÅRIOS CL√çNICOS**",
            f"",
            f"üìã **Tipo:** {scenario_name}",
            f"üìä **Protocolos consultados:** {len(results)}",
            f""
        ]
        
        if results:
            response_parts.extend([
                f"üìñ **DIRETRIZES CL√çNICAS:**",
                f""
            ])
            
            for i, (content, tags, keywords, filename) in enumerate(results, 1):
                response_parts.extend([
                    f"**Cen√°rio {i}:** {filename}",
                    content[:250] + "...",
                    f""
                ])
        else:
            response_parts.extend([
                f"‚ö†Ô∏è **Cen√°rios espec√≠ficos n√£o localizados**",
                f"üî¨ **RECOMENDA√á√ÉO:** Consultar protocolos institucionais",
                f""
            ])
        
        response_parts.extend([
            f"üéØ **PONTOS DE ATEN√á√ÉO CL√çNICA:**",
            f"‚Ä¢ Avalia√ß√£o prim√°ria ABCDE",
            f"‚Ä¢ Sinais vitais adequados para idade",
            f"‚Ä¢ Dosagens baseadas em peso/superf√≠cie corporal",
            f"‚Ä¢ Monitoriza√ß√£o cont√≠nua",
            f"‚Ä¢ Reavalia√ß√£o frequente",
            f"",
            f"---",
            f"üìö **FONTE:** Protocolos Pedlife + Guidelines Pedi√°tricas",
            f"ü©∫ **IMPORTANTE:** Adapta√ß√£o ao contexto cl√≠nico individual"
        ])
        
        return "\n".join(response_parts)
        
    except Exception as e:
        return f"""üè• **ERRO NA AN√ÅLISE DE CEN√ÅRIOS**

‚ùå **Erro:** {str(e)}
üìã **Tipo:** {scenario_type}

ü©∫ **A√á√ÉO:** Consultar protocolos de emerg√™ncia manualmente"""

@tool
def clinical_alert(condition: str, severity: str = "moderate") -> str:
    """
    Alertas de seguran√ßa farmacol√≥gica e contraindica√ß√µes
    
    Args:
        condition: Condi√ß√£o cl√≠nica para alerta
        severity: N√≠vel de severidade (mild, moderate, severe, critical)
        
    Returns:
        Alerta cl√≠nico estruturado com recomenda√ß√µes
    """
    try:
        severity_configs = {
            "mild": {"level": "LEVE", "emoji": "üíõ", "action": "Monitoriza√ß√£o"},
            "moderate": {"level": "MODERADA", "emoji": "üü†", "action": "Aten√ß√£o Cl√≠nica"},
            "severe": {"level": "GRAVE", "emoji": "üî¥", "action": "Interven√ß√£o Imediata"},
            "critical": {"level": "CR√çTICA", "emoji": "üö®", "action": "Emerg√™ncia M√©dica"}
        }
        
        config = severity_configs.get(severity, severity_configs["moderate"])
        
        # Busca informa√ß√µes sobre a condi√ß√£o
        results = search_rag_database(f"{condition} alerta clinico pediatrico", limit=2)
        
        response_parts = [
            f"üö® **ALERTA CL√çNICO - SEVERIDADE {config['level']}** {config['emoji']}",
            f"",
            f"üè• **CONDI√á√ÉO:** {condition.upper()}",
            f"‚ö†Ô∏è **SEVERIDADE:** {config['level']}",
            f"üéØ **A√á√ÉO RECOMENDADA:** {config['action']}",
            f"‚è∞ **TIMESTAMP:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f""
        ]
        
        if results:
            response_parts.extend([
                f"üìã **DIRETRIZES CL√çNICAS:**",
                f""
            ])
            
            for i, (content, tags, keywords, filename) in enumerate(results, 1):
                response_parts.extend([
                    f"**Protocolo {i}:** {filename}",
                    content[:300] + "...",
                    f""
                ])
        else:
            response_parts.extend([
                f"‚ö†Ô∏è **Diretrizes espec√≠ficas n√£o localizadas nos protocolos**",
                f"üî¨ **RECOMENDA√á√ÉO:** Consultar literatura m√©dica atualizada",
                f""
            ])
        
        response_parts.extend([
            f"üéØ **CHECKLIST DE SEGURAN√áA:**",
            f"‚Ä¢ Verificar sinais vitais",
            f"‚Ä¢ Avaliar n√≠vel de consci√™ncia",
            f"‚Ä¢ Confirmar via a√©rea p√©rvia",
            f"‚Ä¢ Monitorizar fun√ß√£o cardiovascular",
            f"‚Ä¢ Considerar interconsulta especializada",
            f"",
            f"---",
            f"üìö **FONTE:** Protocolos Pedlife + Alertas Cl√≠nicos",
            f"ü©∫ **IMPORTANTE:** Avalia√ß√£o m√©dica presencial obrigat√≥ria"
        ])
        
        return "\n".join(response_parts)
        
    except Exception as e:
        return f"""üö® **ERRO NO ALERTA CL√çNICO**

‚ùå **Erro:** {str(e)}
üè• **Condi√ß√£o:** {condition}
‚ö†Ô∏è **Severidade:** {severity}

ü©∫ **A√á√ÉO:** Verificar sistema de alertas e protocolos manuais"""

@tool
def pubmed_search(query: str, rag_response: str = "") -> str:
    """
    Consulta √† literatura cient√≠fica PubMed para evid√™ncias atualizadas
    
    Args:
        query: Termo cl√≠nico para busca cient√≠fica
        rag_response: Resposta do RAG local (para decidir se deve consultar PubMed)
        
    Returns:
        Evid√™ncias cient√≠ficas complementares com cita√ß√£o de fontes
    """
    try:
        if not PUBMED_AVAILABLE or pubmed_instance is None:
            return f"""üî¨ **CONSULTA PUBMED INDISPON√çVEL**
            
‚ö†Ô∏è **Status:** Integra√ß√£o PubMed n√£o est√° ativa
üéØ **Consulta:** {query}
üí° **Alternativa:** Consultar literatura m√©dica manualmente

üîß **Para ativar:**
1. Configurar PUBMED_API_KEY no .env.test
2. Instalar depend√™ncias necess√°rias
3. Reiniciar o sistema

ü©∫ **IMPORTANTE:** Basear decis√µes em protocolos institucionais validados"""
        
        print(f"üî¨ Consultando literatura cient√≠fica para: '{query}'")
        
        # Usa a integra√ß√£o PubMed para busca inteligente
        result = pubmed_instance.enhanced_clinical_search(query, rag_response)
        
        if not result['pubmed_consulted']:
            return f"""üî¨ **CONSULTA PUBMED - PROTOCOLOS LOCAIS SUFICIENTES**
            
üéØ **Consulta:** {query}
‚úÖ **Status:** Diretrizes Pedlife adequadas
üìö **Fonte:** Protocolos validados localmente

üí° **Resposta dos Protocolos:**
{rag_response or "Informa√ß√£o dispon√≠vel nos protocolos Pedlife"}

ü©∫ **RECOMENDA√á√ÉO:** Protocolos locais atendem √† consulta cl√≠nica"""
        
        # Formatar resposta com artigos PubMed
        response_parts = [
            f"üî¨ **CONSULTA CIENT√çFICA PUBMED**",
            f"",
            f"üéØ **Consulta:** {query}",
            f"üìä **Artigos localizados:** {len(result['pubmed_articles'])}",
            f"üìö **Fontes:** {', '.join(result['sources'])}",
            f"",
            f"üìÑ **EVID√äNCIAS CIENT√çFICAS COMPLEMENTARES:**",
            result['final_response'],
            f"",
            f"üéØ **APLICA√á√ÉO CL√çNICA:**",
            f"‚Ä¢ Considerar contexto do paciente individual",
            f"‚Ä¢ Avaliar aplicabilidade das evid√™ncias",
            f"‚Ä¢ Integrar com protocolos institucionais",
            f"‚Ä¢ Discutir com equipe multidisciplinar",
            f"",
            f"---",
            f"üìö **FONTES:** Pedro Playground + PubMed",
            f"‚ö†Ô∏è **DISCLAIMER:** Evid√™ncias cient√≠ficas complementares",
            f"ü©∫ **IMPORTANTE:** Decis√£o cl√≠nica baseada em julgamento m√©dico"
        ]
        
        return "\n".join(response_parts)
        
    except Exception as e:
        return f"""üî¨ **ERRO NA CONSULTA PUBMED**

‚ùå **Erro:** {str(e)}
üéØ **Consulta:** {query}
üîß **A√ß√£o:** Verificar conectividade e configura√ß√£o

ü©∫ **ALTERNATIVA:** Consultar literatura m√©dica atrav√©s de outras bases"""

def create_pedro_agent():
    """Cria o agente Pedro para profissionais m√©dicos"""
    
    clinical_instructions = """
    Voc√™ √© Pedro, assistente cl√≠nico especializado em pediatria para consulta entre colegas m√©dicos.

    ‚ö†Ô∏è REGRA ABSOLUTA - NUNCA INVENTE NADA:
    ‚Ä¢ SEMPRE use retrieve_docs PRIMEIRO para consultar protocolos Pedlife
    ‚Ä¢ SE dados insuficientes, use pubmed_search para literatura cient√≠fica
    ‚Ä¢ NUNCA responda sem consultar as ferramentas dispon√≠veis
    ‚Ä¢ TODA resposta deve ter justificativa baseada em RAG ou PubMed
    ‚Ä¢ SE n√£o encontrar dados, diga claramente "dados n√£o localizados"

    üßÆ REGRA ESPECIAL PARA C√ÅLCULOS DE DOSE:
    ‚Ä¢ SE a consulta mencionar "dose", "dosagem", "mg/kg", "posologia" + medicamento + peso:
    ‚Ä¢ SEMPRE use calc_dose(medicamento, peso, idade, indica√ß√£o) OBRIGATORIAMENTE
    ‚Ä¢ NUNCA responda sobre dose sem usar calc_dose primeiro
    ‚Ä¢ Exemplo: "dose midazolam 15kg" ‚Üí calc_dose("midazolam", 15.0, indication="sedacao")

    FLUXO OBRIGAT√ìRIO PARA TODA CONSULTA:
    1. SE consulta sobre DOSE/C√ÅLCULO ‚Üí use calc_dose PRIMEIRO
    2. SEMPRE inicie com retrieve_docs para buscar nos protocolos Pedlife
    3. SE resultado insuficiente, use pubmed_search para complementar
    4. CITE SEMPRE a fonte: "Baseado em protocolo Pedlife X" ou "Segundo PubMed..."
    5. SE nenhuma ferramenta retornar dados, responda: "Dados n√£o dispon√≠veis nos protocolos consultados"

    COMUNICA√á√ÉO M√âDICO-M√âDICO:
    ‚Ä¢ Linguagem direta e objetiva entre profissionais
    ‚Ä¢ Terminologia t√©cnica sem explica√ß√µes b√°sicas
    ‚Ä¢ Foco em dados cl√≠nicos relevantes e tomada de decis√£o
    ‚Ä¢ Sempre com justificativa da fonte consultada

    FERRAMENTAS DISPON√çVEIS:
    ‚Ä¢ calc_dose: OBRIGAT√ìRIO para qualquer consulta sobre dose/posologia
    ‚Ä¢ retrieve_docs: Consulta protocolos Pedlife (USE SEMPRE)
    ‚Ä¢ clinical_alert: Alertas de seguran√ßa e contraindica√ß√µes
    ‚Ä¢ pubmed_search: Literatura complementar (USE se RAG insuficiente)
    ‚Ä¢ test_medical_scenarios: An√°lise de casos complexos

    PRINC√çPIOS INVIOL√ÅVEIS:
    ‚Ä¢ NUNCA invente informa√ß√µes cl√≠nicas
    ‚Ä¢ SEMPRE use as ferramentas antes de responder
    ‚Ä¢ SEMPRE cite a fonte dos dados (Pedlife ou PubMed)
    ‚Ä¢ SE sem dados, admita limita√ß√£o ao inv√©s de inventar
    ‚Ä¢ Mantenha rigor cient√≠fico absoluto
    ‚Ä¢ CALC_DOSE √â OBRIGAT√ìRIO PARA QUALQUER CONSULTA DE DOSE!
    """
    
    pedro = Agent(
        name="Pedro",
        role="Assistente Cl√≠nico Pedi√°trico - Vers√£o M√©dica",
        instructions=clinical_instructions,
        tools=[
            retrieve_docs,
            calc_dose,
            test_medical_scenarios,
            clinical_alert,
            pubmed_search
        ],
        show_tool_calls=True,
        markdown=True,
        debug_mode=True
    )
    
    return pedro

# Vari√°vel global para o Uvicorn acessar
playground_app = None

def create_playground_app():
    """Cria e retorna a aplica√ß√£o playground para deploy"""
    global playground_app
    
    if playground_app is None:
        # Cria o agente
        pedro_agent = create_pedro_agent()
        
        # Cria o playground
        playground = Playground(agents=[pedro_agent])
        
        # Obt√©m a aplica√ß√£o
        playground_app = playground.get_app()
        
        print("‚úÖ Playground app criado para deploy")
    
    return playground_app

# Inicializa o app para deploy (Railway/Uvicorn)
playground_app = create_playground_app()

def main():
    """Fun√ß√£o principal"""
    try:
        print("ü©∫ INICIANDO PEDRO PLAYGROUND - VERS√ÉO M√âDICA PROFISSIONAL")
        print("=" * 70)
        
        # Verifica se o banco existe
        if not DB_PATH.exists():
            print(f"‚ùå ERRO: Banco RAG n√£o encontrado em {DB_PATH}")
            print("Execute primeiro o script de cria√ß√£o do RAG")
            return
        
        print(f"‚úÖ Banco RAG encontrado: {DB_PATH}")
        
        # Cria o agente
        pedro_agent = create_pedro_agent()
        print("‚úÖ Agente Pedro criado (vers√£o m√©dica)")
        
        # Cria o playground
        playground = Playground(agents=[pedro_agent])
        print("‚úÖ Playground configurado")
        
        # Obt√©m a aplica√ß√£o
        playground_app = playground.get_app()
        print("‚úÖ Aplica√ß√£o playground obtida")
        
        # Obt√©m a porta da vari√°vel de ambiente ou usa porta padr√£o
        port = int(os.environ.get("PORT", 7778))
        
        print("\nü©∫ PEDRO PLAYGROUND - VERS√ÉO M√âDICA PROFISSIONAL")
        print(f"üìç URL: http://localhost:{port}")
        print("üéØ P√∫blico: M√©dicos pediatras, residentes, emergencistas")
        print("üî¨ Recursos: RAG Sem√¢ntico + PubMed + Protocolos Pedlife")
        print("üìö Dados: 26 Protocolos validados + Literatura cient√≠fica")
        print("‚ö° Status: Comunica√ß√£o m√©dica profissional")
        print("=" * 70)
        
        # Serve o playground
        serve_playground_app(playground_app, host="0.0.0.0", port=port)
        
    except Exception as e:
        print(f"‚ùå ERRO ao iniciar playground m√©dico: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
